<!DOCTYPE html>
<html>
<head>
    <title>Quantum Tic Tac Toe</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
        }
        
        #ui {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(25, 25, 25, 0.9);
            padding: 1.5rem;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        button {
            background: #2a2a2a;
            border: none;
            color: #e0e0e0;
            padding: 0.8rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            margin: 0.5rem;
            border: 1px solid #3a3a3a;
        }
        
        button:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }
        
        .stats {
            margin-top: 1rem;
            display: grid;
            gap: 0.8rem;
        }
        
        canvas {
            touch-action: none;
        }
        
        .modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(30, 30, 30, 0.95);
            padding: 2rem;
            border-radius: 16px;
            text-align: center;
            backdrop-filter: blur(15px);
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.4);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="ui">
        <div>
            <button id="newGame">New Game</button>
            <button id="undo">Undo</button>
            <button id="rotate">Rotate</button>
            <button id="settings">Settings</button>
        </div>
        <div class="stats">
            <div>Player X: <span id="scoreX">0</span></div>
            <div>Player O: <span id="scoreO">0</span></div>
            <div>Moves: <span id="moveCount">0</span></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        const APP = {
            config: {
                aiDifficulty: 3,
                rotationSpeed: 0.02,
                animations: true,
                sound: true
            },
            init() {
                this.initScene();
                this.initWASM().then(() => this.newGame());
                this.initUI();
                this.initAudio();
                this.animate();
            },
            async initWASM() {
                const {instance} = await WebAssembly.instantiateStreaming(fetch('game.wasm'), {});
                this.wasm = instance.exports;
                this.wasm.init();
            },
            initScene() {
                this.renderer = new THREE.WebGLRenderer({antialias: true, canvas: document.getElementById('gameCanvas')});
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth/innerHeight, 0.1, 1000);
                this.camera.position.set(5, 5, 5);
                
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                
                this.board = new THREE.Group();
                this.cells = [];
                this.createBoard();
                this.scene.add(this.board);
                
                this.ambient = new THREE.AmbientLight(0x404040);
                this.directional = new THREE.DirectionalLight(0xffffff, 0.8);
                this.directional.position.set(5, 5, 5);
                this.scene.add(this.ambient, this.directional);
            },
            createBoard() {
                const geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                const material = new THREE.MeshPhongMaterial({color: 0x202020});
                
                for(let z = 0; z < 3; z++) {
                    for(let y = 0; y < 3; y++) {
                        for(let x = 0; x < 3; x++) {
                            const cube = new THREE.Mesh(geometry, material);
                            cube.position.set(x-1, y-1, z-1);
                            cube.userData.position = {x, y, z};
                            this.board.add(cube);
                            this.cells.push(cube);
                        }
                    }
                }
            },
            initUI() {
                document.getElementById('newGame').addEventListener('click', () => this.newGame());
                document.getElementById('undo').addEventListener('click', () => this.undoMove());
                document.getElementById('rotate').addEventListener('click', () => this.rotateBoard());
                document.getElementById('settings').addEventListener('click', () => this.showSettings());
                
                this.renderer.domElement.addEventListener('click', e => this.handleClick(e));
                window.addEventListener('resize', () => this.onResize());
            },
            initAudio() {
                this.audio = {
                    place: new Audio('data:audio/wav;base64,UklGRl9...'),
                    win: new Audio('data:audio/wav;base64,UklGRl9...')
                };
            },
            handleClick(e) {
                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                
                raycaster.setFromCamera(mouse, this.camera);
                const intersects = raycaster.intersectObjects(this.cells);
                
                if(intersects.length > 0) {
                    const cell = intersects[0].object.userData.position;
                    this.makeMove(cell.x, cell.y, cell.z);
                }
            },
            async makeMove(x, y, z) {
                if(this.wasm.make_move(x, y, z)) {
                    this.updateBoard();
                    if(this.wasm.get_current_player() === 1 && this.wasm.get_game_state() === 0) {
                        await new Promise(r => setTimeout(r, 1000));
                        this.wasm.ai_move(this.config.aiDifficulty);
                        this.updateBoard();
                    }
                }
            },
            updateBoard() {
                const state = new Uint8Array(this.wasm.memory.buffer, this.wasm.get_board(), 27);
                this.cells.forEach((cell, i) => {
                    cell.material.color.set(state[i] === 1 ? 0xff0000 : state[i] === 2 ? 0x00ff00 : 0x202020);
                });
                this.updateUI();
            },
            newGame() {
                this.wasm.new_game();
                this.board.rotation.set(0, 0, 0);
                this.updateBoard();
            },
            rotateBoard() {
                gsap.to(this.board.rotation, {
                    y: this.board.rotation.y + Math.PI/2,
                    duration: 1.5,
                    ease: 'power3.inOut'
                });
            },
            animate() {
                requestAnimationFrame(() => this.animate());
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            },
            onResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        };

        APP.init();
    </script>
</body>
  </html>
