// src/lib.rs
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub struct Game {
    board: [[[u8; 3]; 3]; 3],
    current_player: u8,
    game_state: u8,
    history: Vec<[[[u8; 3]; 3]; 3]>,
}

#[wasm_bindgen]
impl Game {
    pub fn new() -> Game {
        Game {
            board: [[[0; 3]; 3]; 3],
            current_player: 1,
            game_state: 0,
            history: Vec::new(),
        }
    }

    pub fn make_move(&mut self, x: usize, y: usize, z: usize) -> bool {
        if self.board[z][y][x] != 0 || self.game_state != 0 {
            return false;
        }
        
        self.history.push(self.board.clone());
        self.board[z][y][x] = self.current_player;
        
        if self.check_win(x, y, z) {
            self.game_state = self.current_player;
        } else if self.is_full() {
            self.game_state = 3;
        } else {
            self.current_player = 3 - self.current_player;
        }
        
        true
    }

    fn check_win(&self, x: usize, y: usize, z: usize) -> bool {
        let player = self.board[z][y][x];
        
        let directions = [
            (1, 0, 0), (0, 1, 0), (0, 0, 1),
            (1, 1, 0), (1, 0, 1), (0, 1, 1),
            (1, 1, 1), (1, 1, -1)
        ];

        directions.iter().any(|&(dx, dy, dz)| {
            let mut count = 1;
            for dir in [-1, 1].iter() {
                for i in 1..3 {
                    let xi = x as isize + dx * i * dir;
                    let yi = y as isize + dy * i * dir;
                    let zi = z as isize + dz * i * dir;
                    
                    if xi < 0 || yi < 0 || zi < 0 ||
                       xi >= 3 || yi >= 3 || zi >= 3 {
                        break;
                    }
                    
                    if self.board[zi as usize][yi as usize][xi as usize] == player {
                        count += 1;
                    } else {
                        break;
                    }
                }
            }
            count >= 3
        })
    }

    pub fn ai_move(&mut self, depth: u8) {
        let (best_move, _) = self.minimax(depth as i8, true);
        if let Some((x, y, z)) = best_move {
            self.make_move(x, y, z);
        }
    }

    fn minimax(&self, depth: i8, maximizing: bool) -> (Option<(usize, usize, usize)>, i8) {
        if depth == 0 || self.game_state != 0 {
            return (None, self.evaluate());
        }

        let mut best_val = if maximizing { i8::MIN } else { i8::MAX };
        let mut best_move = None;

        for z in 0..3 {
            for y in 0..3 {
                for x in 0..3 {
                    if self.board[z][y][x] == 0 {
                        let mut new_state = self.clone();
                        new_state.make_move(x, y, z);
                        let (_, val) = new_state.minimax(depth - 1, !maximizing);
                        
                        if maximizing && val > best_val {
                            best_val = val;
                            best_move = Some((x, y, z));
                        } else if !maximizing && val < best_val {
                            best_val = val;
                            best_move = Some((x, y, z));
                        }
                    }
                }
            }
        }
        
        (best_move, best_val)
    }

    fn evaluate(&self) -> i8 {
        match self.game_state {
            1 => 10,
            2 => -10,
            3 => 0,
            _ => 0
        }
    }

    fn is_full(&self) -> bool {
        self.board.iter().flatten().flatten().all(|&cell| cell != 0)
    }

    pub fn get_board_ptr(&self) -> *const u8 {
        self.board.as_ptr() as *const u8
    }
}
